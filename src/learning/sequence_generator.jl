module SequenceGenerator

using Flux: reset!

using ..InputStatistics
using ..ModelUtils: LearningModel, togpu
using ..LevelStatistics

export generatesequence

# TODO handle dataiterparams differences
# TODO Take `reverse_rows` into account!
# TODO and `each_tile`

"""
    generatesequence(model::LearningModel, initialinput::Number)
    generatesequence(model::LearningModel, initialinput::AbstractArray)

Return a sequence generated by applying the given model to the given first screen or input.
An initial screen is given as an `AbstractVector{AbstractVector}` of model inputs while a
single first input is any other `AbstractArray`.

The input will automatically be converted to the correct form in the 1D case.
"""
function generatesequence(model::LearningModel, initialinput::AbstractArray)
    isempty(initialinput) && return [], []
    dimensionality = model.hyperparams[:dimensionality]
    if dimensionality === Symbol("1d")
        generatesequence(model, [i for i in initialinput])
    end
    constantinput = initialinput[eachindex(initialinput)[1:constantinputsize - 1]]
    # Strip constant input part.
    sequence = [initialinput[eachindex(initialinput)[constantinputsize:end]]]
    reset!(model)
    # While the "sequence has not ended yet" bit is not set...
    while sequence[end][1] != 0 && length(sequence) < LevelStatistics.maxcolshori
        push!(sequence, model(togpu(vcat(constantinput, sequence[end]))).data)
    end
    if sequence[end][1] != 0
        println("Force stopped generation due to maximum level length.")
    end
    return constantinput, postprocess(sequence, dimensionality)
end

function generatesequence(model::LearningModel, initialinput::Number)
    generatesequence(model, [initialinput])
end

"""
    generatesequence(model::LearningModel,
                     initialscreen::AbstractVector{<:AbstractVector{<:Number})

Return a sequence generated by applying the given model to the given first screen.
"""
function generatesequence(model::LearningModel, initialscreen::AbstractVector{T}
                          ) where {T <: AbstractVector{<:Number}}
    isempty(initialscreen) && return [], []
    initialinput = first(initialscreen)
    constantinput = initialinput[eachindex(initialinput)[1:constantinputsize - 1]]
    sequence = [inputpart[eachindex(inputpart)[constantinputsize:end]]
                for inputpart in initialscreen]
    reset!(model)
    # Give the model the initial inputs, pre-tuning it (and disregard the predictions.)
    model.(initialscreen[1:end - 1])
    while sequence[end][1] != 0 && length(sequence) < LevelStatistics.maxcolshori
        push!(sequence, model(togpu(vcat(constantinput, sequence[end]))).data)
    end
    if sequence[end][1] != 0
        println("Force stopped generation due to maximum level length.")
    end
    return constantinput, postprocess(sequence, model.hyperparams[:dimensionality])
end

function generatesequence(model, initialinput, dimensionality::AbstractString)
    generatesequence(model, initialinput, Symbol(dimensionality))
end

"""
Return the given sequence's elements as one concatenated `Array`.
The dimensionality of the returned `Array` is determined by the argument of the same name
which allows the following `Symbol`s:
   - Symbol("1d")
   - Symbol("2d")
   - Symbol("3dtiles")
   - Symbol("3d")
"""
function postprocess(sequence::AbstractVector{T},
                     dimensionality::Symbol) where {T <: AbstractVector{Float32}}
    # TODO We could just do `x -> reshape(x, screenrowshori, 1, :)` for most cases.
    # TODO Refactor code so the `fromXd` functions are applied here (need more args then).
    # Remove the "has-not-ended"-bit.
    map!(x -> x[2:end], sequence, sequence)
    if     dimensionality === Symbol("1d")
        return reduce(vcat, sequence)
    elseif dimensionality === Symbol("2d")
        return reduce(hcat, sequence)
    elseif dimensionality === Symbol("3dtiles")
        return reduce(hcat, map(x -> reshape(x, (convert(Int, screenrowshori), 1,
                convert(Int, uniquevanillatiles))), sequence))
    elseif dimensionality === Symbol("3d")
        return reduce(hcat, map(x -> reshape(x, (convert(Int, screenrowshori), 1,
                                                 convert(Int, layers3d))), sequence))
    else
        throw(ValueError("unknown dimensionality"))
    end
end

end # module

